PROJECT: Concurrent Ticket Booking API with Seat Locking

1) Technologies Used:
    a) Node.js: As the asynchronous, event-driven JavaScript runtime environment.
    b) Express.js: As the web application framework for building the RESTful API, managing routes, and handling requests.
    c) JavaScript (ES6+): For handling the application's core logic, state management, and asynchronous operations.


2) Project Overview:
    a) This project is an interactive REST API that simulates a ticket booking system.
    b) It demonstrates how to handle concurrent requests safely by implementing a temporary seat-locking mechanism.
    c) The primary goal was to practice server-side state management, asynchronous logic with timers, and designing an API that prevents common race conditions.
    d) This application serves as a strong foundation for understanding how to build stateful, multi-user backend systems in Node.js.


3) Project File Structure:
    The project is self-contained within a single server file, making it easy to understand the entire application flow in one place.

        Experiment-12/
        ├── node_modules/         # Directory for project dependencies (like Express)
        ├── package.json          # Project metadata and dependency list
        └── index.js              # Main application file containing all logic


4) Structure:
   API Endpoints & State Management:
    The application is built around a central in-memory data store (seats object) that holds the application's state. The logic for viewing, locking, and confirming bookings is handled by distinct API endpoints.

    SNIPPETS:

        i) In-Memory State & Configuration: The core of the app. It uses a simple JavaScript object to represent the "database" of seats and a constant to define the lock duration. All logic revolves around reading and modifying this central state object.
        SNIPPET (server.js - State):

            // Lock timeout in milliseconds (e.g., 60 seconds)
            const LOCK_TIMEOUT = 60 * 1000; 

            // In-memory object to store the state of all seats
            const seats = {
              '1': { status: 'available' },
              '2': { status: 'available' },
              // ... more seats
            };

        ii) Seat Locking Endpoint (POST /lock/:seatId): This endpoint is the heart of the concurrency control. It checks a seat's status and, if available, locks it by updating its state and starting a timer. This timer automatically releases the lock if the booking isn't confirmed in time.
        SNIPPET (server.js - Locking Logic):

            app.post('/lock/:seatId', (req, res) => {
              const seat = seats[seatId];
              const now = Date.now();

              // Check if seat is already booked or currently locked
              if (seat.status === 'booked' || (seat.status === 'locked' && (now - seat.lockTimestamp < LOCK_TIMEOUT))) {
                return res.status(400).json({ message: 'Seat is unavailable' });
              }

              // Lock the seat and set a timestamp
              seat.status = 'locked';
              seat.lockTimestamp = now;

              // Set a timer to automatically release the lock
              setTimeout(() => {
                if (seats[seatId].status === 'locked' && seats[seatId].lockTimestamp === now) {
                  seats[seatId].status = 'available';
              // ... cleanup and log expiration
                }
              }, LOCK_TIMEOUT);

              res.json({ message: `Seat ${seatId} locked successfully.` });
            });

        iii) Booking Confirmation Endpoint (POST /confirm/:seatId): This component validates that a seat has a valid, non-expired lock before permanently changing its status to booked. This ensures that only successfully locked seats can be confirmed.
        SNIPPET (server.js - Confirmation Logic):

            app.post('/confirm/:seatId', (req, res) => {
              const seat = seats[seatId];
              const now = Date.now();

              // Check if the seat is in a 'locked' state
              if (seat.status !== 'locked') {
                return res.status(400).json({ message: 'Seat is not locked' });
              }
  
              // Check if the lock has expired
              if (now - seat.lockTimestamp > LOCK_TIMEOUT) {
                // ... handle expired lock
                return res.status(400).json({ message: 'Lock has expired.' });
              }

              // Confirm the booking
              seat.status = 'booked';
              delete seat.lockTimestamp;
              res.json({ message: `Seat ${seatId} booked successfully!` });
            });


5) Learning Outcomes:
    a) Mastered the use of in-memory JavaScript objects for rapid prototyping of state management.
    b) Gained practical experience with a RESTful API architecture, defining clear endpoints for creating and modifying resources.
    c) Understood how to handle the HTTP request/response cycle in Express, including URL parameters, status codes, and JSON bodies.
    d) Implemented robust server-side validation to handle various user scenarios and edge cases.
    e) Learned to simulate and handle concurrency using asynchronous JavaScript (setTimeout) to prevent race conditions and ensure data integrity.

6) Key Concepts:
    a) In-Memory State Management
    b) RESTful API Design & Routing
    c) HTTP Request/Response Cycle (req/res)
    d) URL Parameters (req.params)
    e) Asynchronous Operations (setTimeout)
    f) Concurrency Control & Race Condition Prevention